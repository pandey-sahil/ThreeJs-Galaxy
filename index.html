<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Spiral Galaxy</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      let scene, camera, renderer, geometry, material, points, controls;
document.querySelector
      const parameters = {
        count: 800000,
        size: 0.001,
        radius: 4 ,
        branches: 8,
        spin: 2,
        randomness: 0.5,
        randomnessPower: 2.25,
        insideColor: "#255170",
        outsideColor: "#78ffff",
      };

      init();
      generateGalaxy();

      function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog("#000005", 5, 15);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        camera.position.set(-1, 4, 6);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // ✅ OrbitControls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // smooth movement
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 20;

        window.addEventListener("resize", onWindowResize);
        animate();
      }

      function generateGalaxy() {
        if (points !== undefined) {
          geometry.dispose();
          material.dispose();
          scene.remove(points);
        }

        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(parameters.count * 3);
        const colors = new Float32Array(parameters.count * 3);

        const colorInside = new THREE.Color(parameters.insideColor);
        const colorOutside = new THREE.Color(parameters.outsideColor);

        for (let i = 0; i < parameters.count; i++) {
          const i3 = i * 3;

          const radius = Math.random() * parameters.radius;
          const spinAngle = radius * parameters.spin;
          const branchAngle =
            ((i % parameters.branches) / parameters.branches) * Math.PI * 2;

          const randomX =
            Math.pow(Math.random(), parameters.randomnessPower) *
            (Math.random() < 0.5 ? 1 : -1) *
            parameters.randomness *
            radius;
          const randomY =
            Math.pow(Math.random(), parameters.randomnessPower) *
            (Math.random() < 0.5 ? 1 : -1) *
            parameters.randomness *
            radius *
            0.3;
          const randomZ =
            Math.pow(Math.random(), parameters.randomnessPower) *
            (Math.random() < 0.5 ? 1 : -1) *
            parameters.randomness *
            radius;

          positions[i3 + 0] =
            Math.cos(branchAngle + spinAngle) * radius + randomX;
          positions[i3 + 1] = randomY;
          positions[i3 + 2] =
            Math.sin(branchAngle + spinAngle) * radius + randomZ;

          const mixedColor = colorInside.clone();
          mixedColor.lerp(
            colorOutside,
            Math.pow(radius / parameters.radius, 1.5)
          );

          colors[i3 + 0] = mixedColor.r;
          colors[i3 + 1] = mixedColor.g;
          colors[i3 + 2] = mixedColor.b;
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        material = new THREE.PointsMaterial({
          size: parameters.size,
          sizeAttenuation: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexColors: true,
          map: generateSprite(),
          transparent: true,
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);
      }

      function generateSprite() {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const context = canvas.getContext("2d");

        const gradient = context.createRadialGradient(
          32,
          32,
          0,
          32,
          32,
          32
        );
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(0.2, "rgba(255, 255, 255, 0.5)");
        gradient.addColorStop(1, "rgba(255, 255, 255, 0)");

        context.fillStyle = gradient;
        context.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
      }

      function animate() {
        requestAnimationFrame(animate);

        if (points) {
          points.rotation.y += 0.0015;
        }

        controls.update(); // ✅ update controls each frame
        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>
